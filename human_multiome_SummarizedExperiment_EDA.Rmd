---
title: "human_multiome_SummarizedExperiment_EDA"
output: html_notebook
---

# Introduction

Here we explore the SummarizedExperiment object output from peak calling script operated on the human multiome. The Granges object derived from the SE object is also explored.

# Intall Libraries
```{r install packages, eval = FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("ComplexHeatmap")
```
# Load Libraries
```{r load libraries}
# Load required libraries
library(SummarizedExperiment)
library(ggplot2)
library(pheatmap)
library(tidyverse)
library(here)
library(ggrepel)
library(ComplexHeatmap)
```
# Load marker features: SummarizedExperiment and GRanges Object
Here we load the results of differential peak analysis conducted using ArchR on the HPC cluster. The results are from ArchR::getMarkerFeatures, which returns a SE object. Also, we load the derived the SimpleList of GRanges object, which was obtained using ArchR::getMarkers() on the SE object. The cutOff param was set so there was no threshold cut off to get all the features.

```{r load SE and GRanges from getMarkerFeatures}
markersPeak <- readRDS(
  here("Plots","human_multiome","human_multiome_harmony_merged_malig_peak",
       "markersPeaks_PIMO_up_status.rds")
)

# SimpleList of GRanges result from peakCalling
# This is extracted from above via ArchR::getMarkers()
markersPeak_gr <- readRDS(
  here("Plots","human_multiome","human_multiome_harmony_merged_malig_peak",
       "markersPeaks_GR_PIMO_up_status.rds")
)

# For PIMOup vs PIMOdown (useGroups=PIMOup, bgdGroups = PIMOdown)
# SE
markersTest <- readRDS(
  here("Plots","human_multiome","human_multiome_harmony_merged_malig_peak",
       "PIMOup_vs_PIMOdown",
       "markersTest_PIMO_up_status_PIMOup_vs_PIMOdown.rds")
)
#GR
markersTest_gr <- readRDS(
  here("Plots","human_multiome","human_multiome_harmony_merged_malig_peak",
       "PIMOup_vs_PIMOdown",
       "markersTest_GR_PIMO_up_status_PIMOup_vs_PIMOdown.rds")
)
```

# Load motifEnrichment Results
Here we load the the output of the motif enrichment script done on the H4h HPC for further EDA and plotting. Specifically, the output is from the script: `run_07_human_multiome_motifEnrichment.sh`, specifically from the ArchR::peakAnnoEnrichment() function.

Each of the results loaded below are derived from different motif sets. A different motif set was assigned to the ArchR object, followed by peakAnnoEnrichment. The default is cisbp, but we also tested homer, which is most closely related to previous in vitro analysis.

```{r load motif enrichment results}
# motifEnrichment

# motifSet = cisbp
motifsUp <- readRDS(file = here("data", "human_multiome", "motifEnrichment", "motifsUp_PIMOup_vs_PIMOdown.rds"))
motifsDown <- readRDS(file = here("data", "human_multiome", "motifEnrichment", "motifsDown_PIMOup_vs_PIMOdown.rds"))
chromVarDev <- readRDS(file = here("data", "human_multiome", "motifEnrichment", "chromVarDeviations_PIMOup_vs_PIMOdown.rds"))

# motifSet = homer
motifsUp_homer <- readRDS(file = here("data", "human_multiome", "motifEnrichment_homer", "motifsUp_PIMOup_vs_PIMOdown_homer.rds"))
motifsDown_homer <- readRDS(file = here("data", "human_multiome", "motifEnrichment_homer", "motifsDown_PIMOup_vs_PIMOdown_homer.rds"))
chromVarDev_homer <- readRDS(file = here("data", "human_multiome", "motifEnrichment_homer", "chromVarDeviations_PIMOup_vs_PIMOdown_homer.rds"))

# check class of objects
class(motifsUp) # SummarizedExperiment
class(chromVarDev) # DFrame

# mouse example:
ms_motifsUp_homer <- readRDS(file = here("data", "mouse_multiome", "motifEnrichment_homer_PIMO_up_status", "motifsUp_PIMOupstatus_homer.rds"))
```

## load custom enrichment with bulk ATAC in multiome
Here we load the result of the custom enrichment analysis where peaks from bulk ATAC-seq were used to compare to multiome results. This was processed by `run_07b_human_multiome_CustomMotifEnrichment.sh`

```{r load custom motif enrichment results}
# load custom enrichment (from ArchR::peakAnnoEnrichment()
# (FDR <= 0.1 & Log2FC >= 0.5)
# bulk_ATAC_DA_peaks
enrichRegions <- readRDS(file = here("data", "human_multiome", "CustomMotifEnrichment", "enrichRegions_customPeaks_bulk_ATAC_DA_peaks_vs_PIMO_up_status.rds"))

class(enrichRegions) # SummarizedExperiment

```

# Exploratory Data Analysis
## SE

```{r eda SE}
#se <- markersPeak
se <- markersTest
# Basic info about the object
dim(se)  # dimensions (Features x samples)
assayNames(se)  # available assay data ("Log2FC"   "Mean"     "FDR"      "Pval"     "MeanDiff" "AUC"      "MeanBGD" )
colnames(se)  # sample names
rownames(se)  # feature

# Metadata exploration
colData(se)  # sample metadata
rowData(se)  # feature metadata
metadata(se)  # experiment metadata

#
rr <- GRanges(rowData(se)$seqnames, IRanges(rowData(se)$start, rowData(se)$end))
rr

# Get the different assays
log2fc <- assay(se, "Log2FC")
mean_expr <- assay(se, "Mean") 
fdr <- assay(se, "FDR")
pval <- assay(se, "Pval")
auc <- assay(se, "AUC")  # Area Under Curve (often from ROC analysis)

# Basic statistics
summary(log2fc)
summary(fdr)

# count NAs in FDR
na_per_comparison <- colSums(is.na(fdr))
print(na_per_comparison)
sum(is.na(fdr)) # 761
```

ArchR has a built in function to draw both volcano and MA plots, and we were interested in reproducing these plots in R from the SE object.

Note, thenumber of features reported in the MA plot from ArchR, which is 167905, seems to be in conflict with the number of rows or features reported in the GRanges object downstream.

We wondered if this is due to NAs in the data?
We observed 761 NAs in FDR column total among all the groups within PIMO_up_status. Recall, we start with a total of 167905 features unfiltered.
167905 - 761 = 167144

Below is a breakdown for each group of PIMO_up_status:
PIMOdown: 167905 - 35 = 167870
PIMOinter: 167905 - 49 = 167856
PIMOup: 167905 - 677 = 167228
The above features for each group match the final Granges dimensions, suggesting that NAs are filtered out.

Thus, we can conclude the MA plots generated by ArchR show each feature (points) even if their FDRs are NA. The MA plots are made based on the SE object, not the derived GRanges object, which filters these out. These are some of the grey dots labelled as Not-differential (see legend).

## Granges
```{r eda GR}
names(markersPeak_gr)
markersPeak_gr[["PIMOdown"]] %>% length # 167870
markersPeak_gr[["PIMOinter"]] %>% length # 167856
markersPeak_gr[["PIMOup"]] %>% length # 167228


markersPeak_gr[["PIMOup"]] %>% 
  subset(Log2FC > 0 & FDR < 1) %>% length # 66921

# cutoff used previous for MA plot
# "FDR <= 0.1 & abs(Log2FC) >= 0.5"
cutOff <- "FDR <= 0.1 & abs(Log2FC) >= 0.5"

markersPeak_gr[["PIMOup"]] %>%
  subset(FDR <= 0.1 & Log2FC >= 0.5) %>% length # 1268
markersPeak_gr[["PIMOup"]] %>%
  subset(FDR <= 0.1 & Log2FC <= -0.5) %>% length # 2059

# count upregulated and downregulated features based on cutOff
for (i in names(markersPeak_gr)) {
  print(paste("For the PIMO_up_status category:", i))
  print(paste("Using threshold: ", cutOff))
  
  up <- markersPeak_gr[[i]] %>%
    subset(FDR <= 0.1 & Log2FC >= 0.5) %>% length
  down <- markersPeak_gr[[i]] %>%
    subset(FDR <= 0.1 & Log2FC <= -0.5) %>% length
  
  print(paste("The number of upregulated features:",up))
  print(paste("The number of downregulated features:",down))
}

# intersect all three granges
# Assume gr1, gr2, gr3 are your GRanges objects
result <- BiocGenerics::Reduce(GenomicRanges::intersect, list(markersPeak_gr[["PIMOup"]], markersPeak_gr[["PIMOup"]], markersPeak_gr[["PIMOup"]]))

GenomicRanges::intersect(markersPeak_gr[["PIMOup"]],markersPeak_gr[["PIMOup"]])

# count NAs
markersPeak_gr[["PIMOup"]]$FDR %>% is.na %>% table # FALSE 167228
markersPeak_gr[["PIMOup"]]$FDR %>% length() # 167228

  
```
When we intersect the GRanges from the three categories, we end up with 166949 features. When the PIMOup GRanges (167228) is intersected with itself, we end up with 166949 as well, suggesting that some features are lost. It's unclear where the features went, and we also checked for NAs.

# Plot TF Rank vs Significance: PIMOup_vs_PIMOdown motifEnrichment from single cell multiome

To better understand motif enrichment results, we can plot the ranking of each motif and their significance. Here we write two functions: motifsSEtoDF() which converts the SE object to a data frame, and plotMotifEnrichments() that takes the data frame and plots the Significance (-log10padj) vs TF rank. 

```{r plotting function for motif enrichment rank vs Significance }
# convert the SE to df for plotting and EDA
motifSEtoDF <- function(motifs) {
  # Convert to data frame for ggplot
  df <- data.frame(TF = rownames(motifs), mlog10Padj = assay(motifs)[, 1])
  df <- df[order(df$mlog10Padj, decreasing = TRUE), ]
  df$rank <- seq_len(nrow(df))
  df$TF_fixed <- sub("_.*", "", df$TF) # remove the _number suffix
df$TF_family <- sub(".*\\.", "", df$TF_fixed) # add a TF family column based on the last suffix
  return(df)
}

# plot TF rank vs significance
# highlight_TF: provide a vector of TFs to highlight if needed
plotMotifEnrichments <- function(df, highlight_TF = NULL) {
  if (length(highlight_TF) > 0) {
    df$highlight <- ifelse(df$TF_fixed %in% highlight_TF, "highlight", "normal")
    gg <- ggplot(df, aes(rank, mlog10Padj)) +
      geom_point(aes(color = highlight), size = 1.5) +
      scale_color_manual(values = c("highlight" = "red", "normal" = "grey70")) +
      ggrepel::geom_label_repel(
        data = subset(df, TF_fixed %in% highlight_TF),
        aes(x = rank, y = mlog10Padj, label = TF_fixed),
        size = 2.5,
        nudge_x = 150,
        nudge_y = 50,
        hjust = 0.5,
        force = 5,
        direction = "both",
        max.overlaps = 15,
        color = "black"
      ) +
      ylab("-log10(P-adj) Motif Enrichment") +
      xlab("Rank Sorted TFs Enriched")

    return(gg)
    
  }else
    gg <- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) +
      geom_point(size = 1.5) +
      ggrepel::geom_label_repel(
        data = df[rev(seq_len(15)), ],
        aes(x = rank, y = mlog10Padj, label = TF_fixed),
        size = 2.5,
        nudge_x = 150,
        nudge_y = 50,
        hjust = 0.5,
        force = 5,
        direction = "both",
        max.overlaps = 15,
        color = "black"
      ) +
      ylab("-log10(P-adj) Motif Enrichment") +
      xlab("Rank Sorted TFs Enriched")
  
  return(gg)
}
```
## motifSet = cisbp (PIMOup_vs_PIMOdown)
Here we have the cisdb motif results of the enrichment between PIMOup_vs_PIMOdown malignant populations.
```{r plot cisbp}
# SE to use
motifsUp
motifsDown

# convert SE to DF for plotting
motifsUp.df <- motifSEtoDF(motifsUp)
motifsDown.df <- motifSEtoDF(motifsDown)

# plot enriched motifs
ggUp <- plotMotifEnrichments(motifsUp.df)
ggDown <- plotMotifEnrichments(motifsDown.df)

ggUp + ggtitle("Enriched Motifs PIMOup vs PIMOdown", subtitle = "top 15 motifsup cisbp")
ggDown + ggtitle("Enriched Motifs PIMOup vs PIMOdown", subtitle = "top 15 motifsDown cisbp")

# highlight motifs of interest
highlight_TF <- c("HIF1A","ARNT", "SOX2", "SOX3", "SOX4", 
                  "SOX6", "SOX9", "SOX10", "SOX15", "Oct4:SOX17")
plotMotifEnrichments(motifsUp.df, highlight_TF) +
  ggtitle("motifsUp cisbp")
plotMotifEnrichments(motifsDown.df, highlight_TF) +
  ggtitle("motifsDown cisbp")
```
## motifSet = homer (PIMOup_vs_PIMOdown)
```{r plot}

motifsUp_homer.df <- motifSEtoDF(motifsUp_homer)
motifsDown_homer.df <- motifSEtoDF(motifsDown_homer)
ms_motifsUp.df <- motifSEtoDF(ms_motifsUp_homer)

ggUp_homer <- plotMotifEnrichments(motifsUp_homer.df)
ggDown_homer <- plotMotifEnrichments(motifsDown_homer.df)
ggup_ms_homer <- plotMotifEnrichments(ms_motifsUp.df)

ggUp_homer + 
  ggtitle("Enriched Motifs PIMOup vs PIMOdown", 
          subtitle = "top 15 motifsUp homer")
ggDown_homer +
  ggtitle("Enriched Motifs PIMOup vs PIMOdown", 
          subtitle = "top 15 motifsDown homer")

# mouse multiome (move later)
ggup_ms_homer

# highlight motifs of interest
highlight_TF <- c("HIF1A","ARNT", "SOX2", "SOX3", "SOX4", 
                  "SOX6", "SOX9", "SOX10", "SOX15", "Oct4:SOX17")
plotMotifEnrichments(motifsUp_homer.df, highlight_TF) +
  ggtitle("motifsUp homer")
plotMotifEnrichments(motifsDown_homer.df, highlight_TF) +
  ggtitle("motifsDown homer")
```

# Table of top motifs

Here we filter the data frames we created earlier for motifs of interest. This is a bit tricky since each motif database names motifs differently in terms of syntax. 

The chromVar DFrame is also converted to data frame for easier access.

```{r top motifs}
# data frames
motifsUp.df
motifsDown.df

# Function: convert chromvar DFrame
motifDRametoDF <- function(DF){
  DF <- as_tibble(as.data.frame(DF))
  DF$TF <- sub("_.*", "", DF$name) # remove the _number suffix # add a TF column
  return(DF)
}
# Convert Chromvar DFrame to dataframe
chromVarDev_homer.df <- motifDRametoDF(chromVarDev_homer)
chromVarDev.df <- motifDRametoDF(chromVarDev) # cisbp

# Function: check motifs of interest in df
checkMotifsInterest <- function(df, motifs){
df_sub <- df %>%
   filter(str_detect(TF, regex(paste(motifs, collapse = "|"), ignore_case = TRUE)))
return(df_sub) # returns subset of df
}

# motifs of interest to check
# motifs <- c("SOX", "HIF", "ARNT", "NF1", "NFI", "FOS", "JUN","AP-1")
motifs <- c("ID1","ID2","ID3","ID4")
# check motifs of interest
checkMotifsInterest(motifsUp.df, motifs)
checkMotifsInterest(motifsDown.df, motifs)
checkMotifsInterest(motifsUp_homer.df, motifs)
checkMotifsInterest(motifsDown_homer.df, motifs)

checkMotifsInterest(chromVarDev_homer.df, motifs)

# join tables
# join motifsup from cisdb and homer: can't join b/c diff naming style
full_join(motifsUp_homer.df, motifsDown_homer.df, by = "TF_fixed") 
```
Note: mlog10Padj means minus log10(adjusted p-value). For Padj < 0.05, we expect the mlog10padj value to be > 1.3.

HIFs are ranked in the bottom 200s/332 from the chromVarDev_homer

# Plot: MA and Volcano

Here we plot the marker peaks using the function implementated from ArchR
```{r plot MA volcano}
plotMarkers_standalone <- function(
  seMarker = NULL,
  name = NULL,
  cutOff = "FDR <= 0.1 & abs(Log2FC) >= 0.5",
  plotAs = "Volcano",
  point_size = 0.5,
  alpha = 0.6,
  rasterize = FALSE
) {
  
  # Input validation
  if (!is(seMarker, "SummarizedExperiment")) {
    stop("seMarker must be a SummarizedExperiment object")
  }
  
  if (is.null(name)) {
    name <- colnames(seMarker)[1]
    message(paste0("No 'name' provided. Using first column: ", name))
  }
  
  if (!name %in% colnames(seMarker)) {
    stop(paste0("'", name, "' not found in seMarker columns. Available columns: ", 
                paste(colnames(seMarker), collapse = ", ")))
  }
  
  if (!plotAs %in% c("Volcano", "MA", "volcano", "ma")) {
    stop("plotAs must be either 'Volcano' or 'MA'")
  }
  
  plotAs <- tolower(plotAs)
  
  # Get available assay names
  assayNames <- names(assays(seMarker))
  
  # Check for required assays
  required_assays <- c("Log2FC", "FDR")
  if (!all(required_assays %in% assayNames)) {
    stop(paste0("Required assays missing. Need: ", paste(required_assays, collapse = ", ")))
  }
  
  # Create environment with assay data for evaluation
  eval_env <- new.env()
  for(an in assayNames) {
    assign(an, assays(seMarker)[[an]], envir = eval_env)
  }
  
  # Evaluate the cutOff expression
  passMat <- eval(parse(text = cutOff), envir = eval_env)
  passMat[is.na(passMat)] <- FALSE
  
  # Extract values for the specified column/group
  FDR <- assays(seMarker)$FDR[, name]
  FDR <- as.numeric(FDR)
  FDR[is.na(FDR)] <- 1
  
  LFC <- assays(seMarker)$Log2FC[, name]
  LFC <- as.numeric(LFC)
  
  # Calculate axis values based on plot type
  if (plotAs == "ma") {
    # Check for required assays for MA plot
    if (!"Mean" %in% assayNames || !"MeanBGD" %in% assayNames) {
      stop("MA plot requires 'Mean' and 'MeanBGD' assays in seMarker")
    }
    
    Mean <- assays(seMarker)$Mean[, name]
    Mean <- as.numeric(Mean)
    MeanBGD <- assays(seMarker)$MeanBGD[, name]
    MeanBGD <- as.numeric(MeanBGD)
    LM <- log2((Mean + MeanBGD)/2 + 1)
    
    x_vals <- LM
    y_vals <- LFC
    x_lab <- "Log2 Mean"
    y_lab <- "Log2 Fold Change"
    
    # Calculate y-axis limits
    qLFC <- max(quantile(abs(LFC), probs = 0.999, na.rm = TRUE), 4) * 1.05
    y_lims <- c(-qLFC, qLFC)
    x_lims <- NULL
    
  } else {  # Volcano plot
    x_vals <- LFC
    y_vals <- -log10(FDR)
    x_lab <- "Log2 Fold Change"
    y_lab <- "-Log10 FDR"
    
    # Calculate x-axis limits
    qLFC <- max(quantile(abs(LFC), probs = 0.999, na.rm = TRUE), 4) * 1.05
    x_lims <- c(-qLFC, qLFC)
    y_lims <- NULL
  }
  
  # Classify features
  color <- ifelse(passMat[, name], "Differential", "Not-Differential")
  color[color == "Differential"] <- ifelse(
    LFC[color == "Differential"] > 0, 
    "Up-Regulated", 
    "Down-Regulated"
  )
  
  # Create plot title with statistics
  n_total <- nrow(seMarker)
  n_up <- sum(color == "Up-Regulated")
  n_down <- sum(color == "Down-Regulated")
  pct_up <- round(100 * n_up / n_total, 2)
  pct_down <- round(100 * n_down / n_total, 2)
  
  plot_title <- paste0(
    "Group: ", name, "\n",
    "Total features: ", n_total, " | ",
    "Up: ", n_up, " (", pct_up, "%) | ",
    "Down: ", n_down, " (", pct_down, "%)"
  )
  
  # Create data frame for plotting (non-differential first, then differential)
  idx <- c(which(color == "Not-Differential"), 
           which(color %in% c("Up-Regulated", "Down-Regulated")))
  
  plot_df <- data.frame(
    x = x_vals[idx],
    y = y_vals[idx],
    color = factor(color[idx], 
                   levels = c("Not-Differential", "Down-Regulated", "Up-Regulated"))
  )
  
  # Define colors
  pal <- c(
    "Up-Regulated" = "#DC143C",      # firebrick3
    "Not-Differential" = "#D3D3D3",   # lightgrey
    "Down-Regulated" = "#1E90FF"      # dodgerblue3
  )
  
  # Create base plot
  p <- ggplot(plot_df, aes(x = x, y = y, color = color)) +
    theme_classic() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      legend.position = "right",
      plot.title = element_text(hjust = 0.5, size = 11)
    ) +
    labs(
      x = x_lab,
      y = y_lab,
      title = plot_title,
      color = "Status"
    ) +
    scale_color_manual(values = pal)
  
  # Add points (with or without rasterization)
  if (rasterize && requireNamespace("ggrastr", quietly = TRUE)) {
    p <- p + ggrastr::geom_point_rast(size = point_size, alpha = alpha)
  } else {
    if (rasterize) {
      message("ggrastr package not available. Plotting without rasterization.")
    }
    p <- p + geom_point(size = point_size, alpha = alpha)
  }
  
  # Add reference line and adjust axes based on plot type
  if (plotAs == "ma") {
    p <- p + 
      geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
      scale_y_continuous(breaks = seq(-100, 100, 2), 
                        limits = y_lims, 
                        expand = c(0, 0))
  } else {  # Volcano
    p <- p + 
      geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
      scale_x_continuous(breaks = seq(-100, 100, 2), 
                        limits = x_lims, 
                        expand = c(0, 0))
  }
  
  return(p)
}
```

```{r plot MA}
# here we plot for PIMOup
# cutOff = "FDR <= 0.1 & Log2FC >= 0.5"
# "FDR <= 1 & Log2FC >= 0"
# markers[["PIMOup"]] %>% dim() # 75393     7
#markers[["PIMOup"]] %>% nrow # 75393
# sum(markers[["PIMOup"]]$FDR < 0.1)

# For PIMOup vs PIMOdown (useGroups=PIMOup, bgdGroups = PIMOdown)
markersTest
plotMarkers_standalone(seMarker = markersTest, name = "PIMOup", plotAs = "Volcano")
plotMarkers_standalone(seMarker = markersTest, name = "PIMOup", plotAs = "MA")
```
Total features from MA/volcano: 166329
# Custom Motif Enrichment
```{r SE EDA custom motif enrichment}

se_eda <- function(se){
# Basic info about the object
dim(se)  # dimensions (Features x samples)
assayNames(se)  # available assay data ("Log2FC"   "Mean"     "FDR"      "Pval"     "MeanDiff" "AUC"      "MeanBGD" )
colnames(se)  # sample names
rownames(se)  # feature

# Metadata exploration
colData(se)  # sample metadata
rowData(se)  # feature metadata
metadata(se)  # experiment metadata
}
se_eda(enrichRegions)

assay(enrichRegions, "mlog10Padj")
```
## ComplexHeatmap
```{r complexheatmap}
# Row-wise scaling function (recreated from ArchR's .rowScale)
rowScale <- function(mat, min = 0, max = NULL) {
  # Store original rownames and colnames
  rn <- rownames(mat)
  cn <- colnames(mat)
  
  # Calculate row-wise min and max
  row_mins <- apply(mat, 1, min, na.rm = TRUE)
  row_maxs <- apply(mat, 1, max, na.rm = TRUE)
  
  # Scale each row to 0-1 range
  mat_scaled <- t(apply(mat, 1, function(x) {
    row_min <- min(x, na.rm = TRUE)
    row_max <- max(x, na.rm = TRUE)
    
    # Avoid division by zero
    if (row_max == row_min) {
      rep(0, length(x))
    } else {
      (x - row_min) / (row_max - row_min)
    }
  }))
  
  # Apply min/max constraints if specified
  if (!is.null(min)) {
    mat_scaled <- mat_scaled * (1 - min) + min
  }
  
  if (!is.null(max)) {
    mat_scaled <- mat_scaled * max
  }
  
  # Restore names
  rownames(mat_scaled) <- rn
  colnames(mat_scaled) <- cn
  
  # Return list with scaled matrix and original max values
  return(list(
    scaled = mat_scaled,
    max = row_maxs,
    min = row_mins
  ))
}



set.seed(42)
mat <- assay(enrichRegions, "mlog10Padj")
mat <- as.matrix(mat)
scaled_result <- rowScale(mat, min = 0)
mat_scaled <- scaled_result$scaled * 100  # Convert to 0-100 scale

Heatmap(t(mat))
Heatmap((mat_scaled))
```

# Motif Bubble plot 
## From bulk ATAC
```{r load motif bubble plot.r}
# load script with bubble plot functions for motifs
source(here("scripts","makeMotifBubblePlot.R"))
# load manually wrangled dataset containing motifs and other statistics from HOMER analysis

motifs_df <- read_csv(here("data","bulkATAC","2021-10-10_2021-10-08_G523_N_VEH_vs_N_BMP_FDR_HOMER_motifs_bubbleplot.csv"),
                      col_names=TRUE)
```

```{r make bubble plot}
MotifBubblePlot(motifs_df, cond = "knownmotif_N_BMP_edgeR")
# iterate thru each dataset
datasets <- motifs_df %>% pull(dataset) %>% unique()
for (i in datasets){
print(i)
  MotifBubblePlot(motifs_df, cond = i) %>% print()
}

```

# Motif Compare: bulk ATAC-seq vs multiome
```{r export multiome homer motifs, eval = FALSE}
write_csv(motifsUp_homer.df, here("data","bulkATAC","2025_10-17_human_multiome_PIMOup_vs_PIMOdown_HOMER_motifsUP.csv"),
                      col_names=TRUE)
write_csv(motifsDown_homer.df, here("data","bulkATAC","2025_10-17_human_multiome_PIMOup_vs_PIMOdown_HOMER_motifsDown.csv"),
                      col_names=TRUE)
```

```{r motif compare}
# from bulk N_BMP_vs_H_BMP
motifs_df <- read_csv(here("data","bulkATAC","2021-10-09_G523_N_BMP_vs_H_BMP_FDR_HOMER_motifs_bubbleplot.csv"),
                      col_names=TRUE)

motifs_df_H_BMP <- motifs_df %>%
  filter(dataset == "knownmotif_H_BMP_deseq2") # deseq2 was used in thesis

motifs_df_N_BMP <- motifs_df %>%
  filter(dataset == "knownmotif_N_BMP_deseq2") # deseq2 was used in thesis

# from human multiome
motifsUp_homer.df
motifsDown_homer.df

# additional cleaning
df1_cleaned <- motifsUp_homer.df %>%
  mutate(
    TF_cleaned = TF %>%
      # Step 1: Remove the numerical suffix (e.g., _251)
      # "AP.1.bZIP_1" -> "AP.1.bZIP"
      str_remove("_\\d+$") %>%
      
      # Step 2: Handle the specific ".T.box" edge case first.
      # "Brachyury.T.box" -> "Brachyury"
      str_remove("\\.T\\.box$") %>%
      
      # Step 3: Now, handle the general case by removing the last remaining 
      # motif identifier (e.g., .bZIP, .DR1).
      # "AP.1.bZIP" -> "AP.1"
      # "RXR.NR..DR1" -> "RXR.NR.."
      str_remove("\\.[^.]+$") %>%
      
      # Step 4: Replace all remaining periods with hyphens.
      # "AP.1" -> "AP-1"
      # "RXR.NR.." -> "RXR-NR--"
      str_replace_all("\\.", "-") %>%
      
      # Step 5: Final cleanup. Remove any trailing hyphens.
      # "RXR-NR--" -> "RXR-NR"
      str_remove("-+$")
  )

df2_cleaned <- motifs_df_H_BMP %>%
  mutate(TF_cleaned = str_extract(TF, "[^|]+"))

df3_cleaned <- motifs_df_N_BMP %>%
  mutate(TF_cleaned = str_extract(TF, "[^|]+"))

# multiome motifsUP vs motifs_H_BMP
common_tfs_1 <- intersect(df1_cleaned$TF_cleaned, df2_cleaned$TF_cleaned)
# multiome motifsUP vs motifs_N_BMP
common_tfs_2 <- intersect(df1_cleaned$TF_cleaned, df3_cleaned$TF_cleaned)

# Updated plotting function
plotMotifEnrichments_new <- function(df, common_tfs_vector, show_labels = TRUE) { #<-- New argument here
  
  # 1. Create a new column to flag common TFs
  df <- df %>%
    mutate(is_common = TF_cleaned %in% common_tfs_vector)
  
  # 2. Create the base plot
  gg <- ggplot(df, aes(x = rank, y = mlog10Padj)) + 
    geom_point(aes(color = is_common, shape = is_common), size = 2.5, alpha = 0.8) +
    scale_color_manual(name = "Common TF", values = c(`TRUE` = "red", `FALSE` = "grey50")) +
    scale_shape_manual(name = "Common TF", values = c(`TRUE` = 17, `FALSE` = 16)) +
    ylab("-log10(P-adj) Motif Enrichment") + 
    xlab("Rank Sorted TFs Enriched") +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 4)))
  
  # 3. Conditionally add labels
  # This 'if' statement checks if show_labels is TRUE
  if (show_labels) {
    gg <- gg + geom_label_repel(
      data = filter(df, is_common),
      aes(label = TF_cleaned),
      size = 3,
      force = 10,
      max.overlaps = Inf,
      color = "black",
      segment.color = "grey50",
      nudge_y = 5
    )
  }
  
  return(gg)
}

gg_compare1 <-plotMotifEnrichments(df1_cleaned) # [1] 332   6
gg_compare2 <-plotMotifEnrichments_new(df1_cleaned, common_tfs_1)
gg_compare3 <-plotMotifEnrichments_new(df1_cleaned, common_tfs_1,FALSE)

pdf(here("Plots","2025-10-17_human_multiome_PIMOup_vs_PIMOdown_motifUP_vs_G523_H_BMP_vs_N_BMP_motif_ranking_bulk.pdf"))
gg_compare1
gg_compare2
gg_compare3
dev.off()

```